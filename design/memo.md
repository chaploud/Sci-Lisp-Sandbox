# 開発メモ

そもそもどこからscilispで記述すべきなのか想像がついてない
Rustの機能はフルに活かしたい
そこまで厳格な型システムを要求しないが、ポリモーフィズムを達成するために何かしらの工夫が必要

まず言語化できていない

激しい道のり
wasmのスタック操作までさかのぼって自作する
すべての型をwasmの範疇で定義する
⇒やりたくない

中程度の道のり
基本型に関してはRustのものを流用する
関数に関してもそれに乗っかる
Sci-Lispとの接続が難しい
RustInterOpを用意しておく
Rustの関数を呼び出して楽をする
コンパイルされて最適化されてアクセス不能にならないか？

- Code As Dataだからといって、いろいろな機能を高速に提供しようとしたら、普通の言語のようにキーワード特化のAST構成、パースをしなければならない。ので、うまい統一的なやり方ではなく個別撃破していくのだ。

- 今一度Doraの先読みをして、全体像を掴んでおくことは大切
- 説明を書き出してみよう
- 結合テストを先に書き出してみようか => 設計ができる



## やりたいことの言語化

- Rustで基本関数等定義をできるようにしておく
- WIT形式で取り扱いを始める
- Sci-Lispの世界へ入る

## JITの教科書

https://github.com/dinfuehr/dora

- 16万行
- 命令セットにいたるまですべて自前で実装している感じ
- bytecodeをwasmにすればいいと思う

### 処理の流れ

- どのように処理実行しているかの流れだけでもつかめ

- dora/src/main.rs
  - driver::start()
- dora/src/driver/start.rs
  - start()
    - cmd::parse_arguments()
    - compile_into_program()
      - Sema::new() ... Semaphoreかな? -> sm
      - Semaがメモリ上でのデータ構造すべてもっている感じか
    - language::check_program(); -> ast
    - language::generate_bytecode()
    - language::emit_program() -> program
      - language::emit_bytecode()
    - encode_and_decode_for_testing()
    - set_vm()
    - run_main()

- これをSci-Lispの実行に置き換えてみよう
- 実行時引数
  - REPL
  - Execute File
- semaphoreの上にlanguage::check_program -> ast
- semaphoreからgenerate_bytecode -> wasm
- wasmetimeで実行

- メモリアリーナ・アリーナメモリアロケータ
- まずはsemaを読んで、どのようにASTを保持したいのかを理解してみる

- 再帰の高速化、スタックオーバーフローしにくさ
  - 内部でloopに変換かな

## 必要なデータ構造・オブジェクト

入念に読んで理解してから実装に移ろう

- プログラムへの引数
- interner: インターンするもの
- source_file: ソースファイル情報
- diag: エラー分析して出すもの
- known: 既出のオブジェクト
  - functions
  - enums
  - structs
  - macros
- aliases: モジュールエイリアス、型エイリアス
- consts: constによるもの
- structs: structsによるもの
- extensions: わからん
- fcts: defnによるもの
- enums: enumによるもの
- globals: グローバル変数
- uses: importに該当するな
  - export表現がないからどうするか
- packages: 依存関係を表すパッケージ(まだ先か)
- package_names: パッケージの名前、ID
- prelude_module_id: Rustでpreludeというと、そのライブラリをがっと使えるようにするやつ
- stdlib_module_id: モジュールID
- program_module_id: プログラムのモジュールID->REPLでの表現は?一プロセスあたりに割り振られるかな？
- boots_module_id: コンパイラの方式
- stdlib_package_id: こっちはパッケージ
- program_package_id: 〃
- boots_package_id: 〃

## Arena

```rust
pub struct Arena<T, A = DefaultArenaBehavior<T>> {
  arena_id: u32,
  items: Vec<T>,
  _phantom: PhantomData<fn() -> A>
}
```

Sema構造体内のArenaからデータをidで高速に取り出すことができるっぽい
- メモリ上の構造を表す


## REPLのスペシャルコマンド

- %e: 直前のエラー
- %run: 外部モジュールの実行。結果格納

## 高速なJIT言語についての着目点

バイトコード式VMプログラミング言語を高速化するためには、いくつかのポイントに注意する必要があります。以下は、そのための10個以上のヒントです：

1. **バイトコードの最適化**: 不要な命令や冗長な命令を排除し、効率的なバイトコード列を生成します。これにより、VMの実行速度が向上します。

2. **ジャストインタイムコンパイル（JIT）**: バイトコードを実行する際に、一部のコードをネイティブコードに変換するJITコンパイラを導入することで、実行速度を向上させることができます。

3. **キャッシュ効率の最適化**: 関数や変数のルックアップに使用されるデータ構造やアルゴリズムを選択し、キャッシュの効率的な利用を促進します。例えば、ハッシュテーブルを使用することで、高速なルックアップを実現できます。

4. **インライン展開**: 関数呼び出しのオーバーヘッドを削減するために、適切な場合に関数の中身をその場所に直接展開します。

5. **ジャンプテーブルの最適化**: ジャンプテーブルを使用して命令のディスパッチを行う場合、そのテーブルをキャッシュフレンドリーに配置することが重要です。

6. **局所性の活用**: メモリアクセスパターンを最適化し、キャッシュの局所性を活用します。関連するデータに連続的なアクセスを促進し、キャッシュミスを最小限に抑えます。

7. **メモリ管理の最適化**: メモリアロケーションと解放のオーバーヘッドを減らすために、効率的なメモリ管理アルゴリズムを採用します。

8. **ハードウェア機能の活用**: VMの実行環境が利用可能なハードウェア機能（例：SIMD命令、マルチスレッド処理、ハードウェアアクセラレーション）を活用して、処理を高速化します。

9. **プロファイリングと最適化**: パフォーマンスのボトルネックを特定し、最も時間を要する部分に焦点を当てて最適化を行います。プロファイリングツールを使用して、実行時の性能を評価します。

10. **適切なデータ構造の選択**: 実行時のデータの表現方法を選択する際に、最適なデータ構造を使用します。例えば、高速なスタックやキューの実装には、適切なデータ構造を選択することが重要です。

11. **オーバーヘッドの削減**: VMの各部分における余分なオーバーヘッドを削減します。これには、命令デコード、スタック操作、メモリ管理などが含まれます。

これらのヒントを考慮しながら、バイトコード式VMプログラミング言語の開発を行うと、高速な実行環境を実現できます。

## Wasmへのコンパイル

- 実行環境はwasmer/wasmtime
- 最適化?
- どういうコードを吐き出すべきか

## 言語仕様

- リテラル: よし
- falsy value: よし
- Lisp-1: よし
- 動的型付け言語: like Julia
- 基本的なコレクション: 5種
- スコープの形成: let/defn/struct/method/macro
- スペシャルフォームの処理
  - 速度実現のためにRustによる組み込み処理

### 迷いどころ

- const: 内部不変
  - 実現が少し困難になる
  - それらの組み合わせ
  - あとでバッと組み合わせたらいいかなぁ
  - 状態変更を行う関数にアノテーションをつける?

- WasmへのJIT
  - Wasmで最も高速な実装をする

- GC
  - 工夫する

- Rust InterOp
  - Rustのオブジェクトを扱える
  - 型、関数、クラス

- 機能はRust InterOpを通じて行う

### 使用クレート

- コマンドライン
  - clap
- REPL
  - rustyline
- 字句解析
  - nom
- メモリ管理
  - Arena
  - GC
- 変数管理
  - intern

- doraを読んで、全体像を掴んで置く必要がある

### doraリーディングメモ

- コマンドライン引数処理
- `compile_into_program`
  - `Sema::new()`
  - 色んなものの `Arena::new()`
    - `id-arena` クレート
  - `check_program`
    - `parser::parse()`
      - `prepare_packages()`
      - `add_all_packages()`
      - `parse_file()`
